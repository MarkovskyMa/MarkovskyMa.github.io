<!DOCTYPE html>
<html lang="chinese (simplified)">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>《Python的背后》阅读记录</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="阅读公众号“古明地觉的编程教室”的一份合集《Python的背后》，做些记录。" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">呼呼大睡的博客</a></h1>
                <nav><ul>
                    <li><a href="/category/dian-ying.html">电影</a></li>
                    <li><a href="/category/gong-ju.html">工具</a></li>
                    <li><a href="/category/hua-ying.html">画影</a></li>
                    <li class="active"><a href="/category/ji-suan-ji.html">计算机</a></li>
                    <li><a href="/category/shi-ci.html">诗词</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/behind-python.html" rel="bookmark"
           title="Permalink to 《Python的背后》阅读记录">《Python的背后》阅读记录</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2023-11-10T00:00:00+08:00">
                Published: 周五 10 十一月 2023
        </abbr>
		<br />
        <abbr class="modified" title="2023-11-10T11:00:00+08:00">
                Updated: 周五 10 十一月 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/hu-hu-da-shui.html">呼呼大睡</a>
        </address>
<p>In <a href="/category/ji-suan-ji.html">计算机</a>.</p>
<p>tags: <a href="/tag/gong-ju.html">工具</a> <a href="/tag/bian-cheng.html">编程</a> <a href="/tag/ji-suan-ji.html">计算机</a> <a href="/tag/python.html">Python</a> </p>
</footer><!-- /.post-info -->      <p>公众号“古明地觉的编程教室”的合集《Python的背后》写了不少关于Python内在机制的知识，
值得一读。本文针对的是截止到2023年11月10日的合集，有20篇文章。</p>
<p>（公众号中另有一个系列《源码探秘 CPython》，有近百篇文章，太多了，暂时看不过来。）</p>
<p>本文不是复制公众号文章，而是阅读后的总结记录。</p>
<p>实际翻了一遍下来，发现文章实在是太多了。所以这里只是简单汇总了一下，
还是应该以此为出发点去直接看更系统性的内容，因为说实话有些内容其实是一些小细节、小问题的分析。</p>
<p>这些文章并没有看完，所以这篇阅读记录是需要长期更新的。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/JLr0VFsulcDoRlO26-0CGg">由一个简单的引用计数问题引发的一些思考</a></p>
<p>关于Python的引用计数问题，涉及到Python的编译运行机制。
同样的一个对象在执行Python文件和交互式环境中调用 <cite>sys.getrefcount()</cite> 的结果不一样。
关键还是这一段：</p>
<blockquote>
<p>那么问题来了，为啥在交互式环境里面打印的是 2 呢？首先，如果是在 PyCharm 里面右键单击执行的话，
那么 py 文件会作为一个整体编译。然后查看引用计数的时候，
它所在的编译单元并没有被销毁，因为它们在同一个编译单元当中。</p>
<p>但如果是交互式环境，那么每一行独立的可执行语句都会对应一个独立的编译单元。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/uulpRYQSzEVCllpUBd5YjA">深度解密 __init_subclass__ 到底是个啥？</a></p>
<p>介绍了 <cite>__init_subclass__</cite> 这个特殊的函数，可以用来实现元编程的部分功能。
关于Python元编程，这是一个比较大的话题，而且元编程也算是奇技淫巧了。</p>
<blockquote>
<p>所以 Python 提供了一个名为 __init_subclass__ 的特殊成员函数，当某个类被继承时，会自动触发。</p>
<p>……</p>
<p>可以看到，我们在不使用元类的情况下，通过 <cite>__init_subclass__</cite> 实现了类的自定义过程。
当然示例比较简单，你也可以实现更复杂的逻辑，总之在某些场景下我们能用 __init_subclass__ 替代元类。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/oL32iJGdT4mLhU4vAuwKjA">深度解密 Python 列表的实现原理</a></p>
<p>由粉丝提问Python中列表和字典在读取和写入数据上的效率对比问题出发，先介绍列表的实现原理。</p>
<p>列表作为Python最重要的数据结构，讲Python原理肯定要讲列表，关键就是如何用C语言的指针直线列表的。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/oL32iJGdT4mLhU4vAuwKjA">一文让你彻底搞懂 Python 字典是怎么实现的</a></p>
<p>上一篇写的列表，这一篇写字典，同样很重要。理解字典的关键是理解哈希算法。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/H-7LzpgWWDnZUuQxpWeWjw">type 与 object 之间的恩怨纠葛</a></p>
<p>Python奉行“一切皆对象”的原则，所以对象的类型也是对象，
看起来object和type成了一个“鸡生蛋，蛋生鸡”的套娃问题。</p>
<blockquote>
<p>因此到目前为止，type 和 object 之间的恩怨纠葛算是真相大白了，总结一下：</p>
<p>1）和自定义类不同，内置的类不是由 type 实例化得到的，它们都是在底层预先定义好的，不存在谁创建谁。
只是内置的类在定义的时候，它们的类型也都被设置成了 type。这样不管是内置的类，还是自定义类，
在调用时都会执行 type 的 __call__ 方法，从而让它们的行为是一致的。</p>
<p>2）虽然内置的类在底层预定义好了，但还有一些瑕疵，因为有一部分逻辑无法以源码的形式体现，
只能在解释器启动的时候再动态完善。而这个完善的过程，便包含了基类的填充，会将基类设置成 object。</p>
<p>所以 type 和 object 是同时出现的，它们的存在需要依赖彼此。首先这两者会以不完全体的形式定义在源码中，
并且在定义的时候将 object 的类型设置成 type；然后当解释器启动的时候，再经过动态完善，
进化成完全体，而进化的过程中会将 type 的基类设置成 object。</p>
<p>所以 object 的类型是 type，type 继承 object 就是这么来的。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/aEjiW1M08gbgiylfNx8aWg">Python 的整数是怎么实现的？这篇文章告诉你答案</a></p>
<p>Python的整数是不会溢出的，当然还是受限于内存大小，但是不像C语言一样还要区分整型和长整型。
整数的实现也是Python源码的重点。</p>
<blockquote>
<p>以上我们就考察了整数的底层实现，了解了它不会溢出的奥秘，但也正如我们所说的，
使用数组实现大整数并不是什么特别新颖的思路。它的难点在于数学运算，这是非常考验编程技巧的地方。</p>
<p>而且我们这里只是分析了加减法，而乘除更加复杂，这里就不再分析了。
而且我们发现，简单的整数运算 Python 居然做了这么多工作，这也侧面说明了 Python 的效率不高。</p>
<p>当然了，Python 内部也定义了很多快分支，会提前检测能否使用快速通道进行处理。
当无法使用快速通道时，再走通用逻辑。</p>
</blockquote>
<p>这里说的“快分支”应该对应于计算机体系结构中的分支预测？</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/c5wJnbec944DbZ-7fX9lFA">通过 Cython 带你认清 Python 变量的本质</a></p>
<blockquote>
Python 和其它静态语言之间有一个显著的不同，就是 Python 的变量其实只是一个名字。
站在 C 语言的角度来看，Python 变量本质上就是一个指针（准确的说是引用），
存储的是对象的内存地址，指针指向的内存才是对象。</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/ASAMuBLBbVEazyPDsdCb2A">Python 的集合是怎么实现的？</a></p>
<p>又一个重点的内置数据结构：集合。</p>
<blockquote>
<p>以上就是集合相关的内容，它的效率也是非常高的，能够以O(1)的复杂度去查找某个元素。
最关键的是，它用起来也特别的方便。</p>
<p>此外 Python 里面还有一个 frozenset，也就是不可变的集合。
但 frozenset 对象和 set 对象都是同一个结构体，只有 PySetObject，没有 PyFrozenSetObject。</p>
<p>我们在看 PySetObject的时候，发现该对象里面也有个 hash 成员，如果是不可变集合，
那么 hash 值是不为 -1 的，因为它不可以添加、删除元素，是不可变对象。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/fPmo14sBZXJgEUodTL7y1g">关于 Python 列表解析式的作用域问题</a></p>
<p>简短的一篇，讲列表表达式的一个坑，关于作用域的坑。作用域的细节看下面的文章。</p>
<blockquote>
我被坑的原因是，列表解析式具有独立的作用域这一结论在 Python3 当中是成立的，但在 Python2 当中不成立。</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/u55Vzpy8rHXdCwvx-_XACQ">解密 Python 迭代器的实现原理</a></p>
<blockquote>
<p>到此，我们再次体会到了 Python 的设计哲学，通过 PyObject * 和 ob_type 实现了多态。
原因就在于它们接收的不是对象本身，而是对象的 PyObject * 泛型指针。</p>
<p>不管变量 obj 指向什么样的可迭代对象，都可以交给 iter 函数，会调用类型对象内部的 __iter__，
底层是 tp_iter，得到对应的迭代器。不管变量 it 指向什么样的迭代器，
都可以交给 next 函数进行迭代，会调用迭代器的类型对象的 __next__，底层是 tp_iternext，将值迭代出来。</p>
<p>至于__iter__和__next__本身，每个迭代器都会有，我们这里只以列表的迭代器为例。</p>
<p>回顾整个过程，会发现这是不是实现了多态呢？</p>
</blockquote>
<p>越来越感觉Python（严格说是CPython）就是C语言的高级库。泛型指针是C语言的内容。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/AygMub1DOe0PNxF_gxzHUw">深度解密 Python 的字节码</a></p>
<p>重点来了！字节码就是Python虚拟机的指令，在Python中有一些操作字节码的库。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/5bSv33i4QHWoH7NYPvnqcw">一文让你搞懂 Python 的 pyc 文件</a></p>
<p>承载Python字节码的文件：pyc文件。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/XTm_jh9UD7mAPY1ZmoHLXA">解密虚拟机的执行环境：栈帧对象</a></p>
<blockquote>
<p>前面我们介绍了 Python 的 PyCodeObject 对象，它是解释器对源代码编译之后的结果。
该对象内部有很多属性，比如 co_code 负责存储相应的字节码，也就是虚拟机要执行的指令序列；
co_names、co_consts 等等则负责存储代码中的符号、常量等静态信息。</p>
<p>那么问题来了，既然源代码在经过编译之后，
所有字节码指令以及相关的静态信息都存储在 PyCodeObject 对象当中，
那么是不是意味着虚拟机就在 PyCodeObject 对象上进行所有的动作呢？</p>
<p>答案显然不是的，虽然 PyCodeObject 包含了关键的字节码指令以及静态信息，
但有一个东西是没有包含、也不可能包含的，就是程序在运行时的执行环境，
这个执行环境在 Python 里面叫做栈帧。</p>
</blockquote>
<p>作者说这是为了介绍协程准备的前置内容。</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/DpQ88gNuIH9Qqu8l-DeYqg">解密 Python 的作用域和名字空间</a></p>
<blockquote>
<p>名字空间是 Python 的灵魂，它规定了一个变量应该如何查找，而名字空间是作用域的动态体现。
整个 py 文件是一个作用域，也是全局作用域；定义函数、定义类、定义方法，
又会创建新的作用域，这些作用域层层嵌套。</p>
<p>那么同理，运行时的名字空间也是层层嵌套的，形成一条名字空间链。
内层的变量对于外层是不可见的，但外层的变量对内层是可见的。</p>
<p>然后全局名字空间是一个字典，它是唯一的，操作里面的键值对等价于操作全局变量；</p>
<p>至于局部名字空间则不唯一，每一个函数都有自己的局部名字空间，
但我们要知道函数内部在访问变量的时候是静态访问的。</p>
<p>还有内置名字空间，可以通过 __builtins__ 获取，但拿到的是一个模块，
再获取它的属性字典，那么就是内置名字空间了。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/7XXxa8vA6Bnz6aQyg5DTkA">一文让你搞懂 Python 虚拟机执行字节码的奥秘</a></p>
<blockquote>
以上我们就研究了虚拟机是如何执行字节码的，相信你对 Python 虚拟机也有了更深的了解。
说白了虚拟机就是把自己当成一颗 CPU，在栈帧中不停地执行字节码指令。
而执行逻辑就是 _PyEval_EvalFrameDefault 里面的那个大大的 for 循环，
for 循环里面有一个巨型 switch，case 了所有的分支，不同的分支执行不同的逻辑。</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/hdyufXZJXl1lNQ0gJSVovg">解密 Python 函数的实现原理</a></p>
<blockquote>
<p>函数是任何一门编程语言都具备的基本元素，它可以将多个要执行的操作组合起来，
一个函数代表了一系列的操作。而且在调用函数时会干什么来着，没错，要创建栈帧，用于函数的执行。</p>
<p>那么下面就来看看函数在 C 中是如何实现的，生得一副什么模样。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/BTlgHXwIuN01HpKT2aJwLA">深度解密函数的 local 名字空间（当 Python 中混进一只薛定谔的猫……）</a></p>
<blockquote>
<p>以上我们就探讨了 local 名字空间相关的内容，它是真实存在的局部变量的一个拷贝，
每当我们调用一次 locals，都会拷贝一次。</p>
<p>然后函数的局部变量都是静态存储的，编译时就已经确定，无法在运行时动态添加。
我们往局部名字空间里面添加键值对，并不等价于创建局部变量。</p>
</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/yrP3Mfn8QnS-LR5mFwOMZg">用一篇文章告诉你如何篡改 Python 虚拟机</a></p>
<p>用Python内置的ctypes模块对Python虚拟机进行修改。（注意不能用于生产环境，仅自娱自乐！）</p>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/wBjag5x3T5zj3C-wUYUmgw">带你重温一下 Python 的对象模型</a></p>
<blockquote>
在面向对象的理论中，有两个核心的概念：类和实例。
类可以看成是一个模板，实例就是根据这个模板创建出来的对象。
但在 Python 里面，类和实例都是对象，也就是所谓的类对象（或者类型对象）和实例对象。</blockquote>
<hr class="docutils" />
<p><a class="reference external" href="https://mp.weixin.qq.com/s/0hDfAb1fYCNM_SUSuX57Gg">深度解密为什么实例在调用方法时会将自身传给 self 参数</a></p>
<p>关键是Python的描述符机制。</p>
<blockquote>
<p>以上我们就探讨了为什么实例调用方法时，会自动将自身传给 self，说白了就是因为描述符机制。
像 property、staticmethod、classmethod 等等都是通过描述符来实现的，
描述符在 Python 里面是一个很强大的机制，但使用的频率却不高，更多的是在一些框架的源码中出现。</p>
<p>然后我们还探讨了属性引用，查看了 Python 中访问属性对应的逻辑在底层是如何实现的。
当然啦，也解析了方法和函数的区别，以及它们在底层的调用方式。</p>
</blockquote>
<div class="section" id="section-1">
<h2>参考：</h2>
<ol class="arabic simple">
<li>古明地觉的编程教室。公众号，其中有很多Python相关的内容，特别是进阶内容。</li>
</ol>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">邮箱（Email）：2493983815@qq.com</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>